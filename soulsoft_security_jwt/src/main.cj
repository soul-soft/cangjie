package soulsoft_security_jwt

import std.fs.*
import std.io.*
import stdx.crypto.digest.*
import stdx.crypto.x509.*
import stdx.crypto.keys.*
import stdx.encoding.hex.*

main(): Int64 {
    //let securityKey = SymmetricSecurityKey("your-256-bit-secret-key-herefaaaaaaaaaaaaaaaa".toArray())
    let privateKey = ECDSAPrivateKey.decodeFromPem(String.fromUtf8(readToEnd(File("ec256-private.pem", OpenMode.Read))))
    let publicKey = ECDSAPublicKey.decodeFromPem(String.fromUtf8(readToEnd(File("ec256-public.pem", OpenMode.Read))))
    let securityKey = ECDsaSecurityKey(publicKey: publicKey, privateKey: privateKey)
    let header = JwtHeader(SigningCredentials(securityKey, SecurityAlgorithms.EcdsaSha256))
    let payload = JwtPayload([("sub", "jwt")])
    var jwtToken = JwtSecurityToken(header, payload)
    let tokenHandler = JwtSecurityTokenHandler()
    tokenHandler.writeToken(jwtToken) |> println
    var parameters = TokenValidationParameters(securityKey)
    let claims = tokenHandler.validateToken(tokenHandler.writeToken(jwtToken), parameters)
    for (pattern in claims.claims) {
        println("${pattern.name}=${pattern.value}")
    }
    return 0
}
